<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ajedrez 3D con Animaciones</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
    }
    #mensaje-captura {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.1);
      color: #0ff;
      font-size: 24px;
      padding: 10px 20px;
      border: 2px solid #0ff;
      border-radius: 10px;
      display: none;
      z-index: 2;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="mensaje-captura">¡Captura estratégica!</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let pieza, torre, caballo;

    const container = document.getElementById('canvas-container');
    const mensajeCaptura = document.getElementById('mensaje-captura');

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 6;
      camera.position.y = 2;
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x888888);
      scene.add(ambientLight);

      const light = new THREE.PointLight(0xffffff, 1);
      light.position.set(5, 5, 5);
      scene.add(light);

      // Base para visualización
      const groundGeo = new THREE.PlaneGeometry(10, 10);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Pieza objetivo a capturar
      const geometriaPieza = new THREE.SphereGeometry(0.5, 32, 32);
      const materialPieza = new THREE.MeshStandardMaterial({ color: 0xff00ff });
      pieza = new THREE.Mesh(geometriaPieza, materialPieza);
      pieza.position.set(-2, 0.5, 0);
      scene.add(pieza);

      // Caballo
      const geometriaCaballo = new THREE.ConeGeometry(0.3, 1, 32);
      const materialCaballo = new THREE.MeshStandardMaterial({ color: 0x00ffff });
      caballo = new THREE.Mesh(geometriaCaballo, materialCaballo);
      caballo.rotation.x = Math.PI / 2;
      caballo.position.set(2, 0.5, 0);
      scene.add(caballo);

      // Torre
      const geometriaTorre = new THREE.CylinderGeometry(0.3, 0.3, 1, 32);
      const materialTorre = new THREE.MeshStandardMaterial({ color: 0xffff00 });
      torre = new THREE.Mesh(geometriaTorre, materialTorre);
      torre.position.set(0, 0.5, -2);
      scene.add(torre);

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function animarCaptura(piezaCapturada) {
      const duration = 1000;
      const start = performance.now();
      const startScale = piezaCapturada.scale.clone();
      const endScale = new THREE.Vector3(0.1, 0.1, 0.1);

      mensajeCaptura.style.display = 'block';
      setTimeout(() => mensajeCaptura.style.display = 'none', 1200);

      function shrink(time) {
        const elapsed = time - start;
        const t = Math.min(elapsed / duration, 1);
        piezaCapturada.scale.lerpVectors(startScale, endScale, t);
        if (t < 1) requestAnimationFrame(shrink);
        else scene.remove(piezaCapturada);
      }
      requestAnimationFrame(shrink);
    }

    function animarCaballo() {
      let start = null;
      const duracion = 1000;
      const amplitud = 0.3;
      const frecuencia = 10;

      function trotarCaballo(tiempo) {
        if (!start) start = tiempo;
        const progreso = (tiempo - start) / duracion;
        caballo.position.y = 0.5 + Math.sin(progreso * frecuencia * Math.PI) * amplitud;
        caballo.position.x = 2 - progreso * 4;

        if (progreso < 1) requestAnimationFrame(trotarCaballo);
        else caballo.position.y = 0.5;
      }

      requestAnimationFrame(trotarCaballo);
    }

    function animarTorre() {
      let start = null;
      const duracion = 800;

      function deslizarTorre(tiempo) {
        if (!start) start = tiempo;
        const progreso = (tiempo - start) / duracion;
        torre.position.z = -2 + progreso * 4;

        if (progreso < 1) requestAnimationFrame(deslizarTorre);
      }

      requestAnimationFrame(deslizarTorre);
    }

    // Iniciar
    init();

    // Secuencia de animación
    setTimeout(() => {
      animarCaballo();
    }, 1000);

    setTimeout(() => {
      animarTorre();
    }, 2500);

    setTimeout(() => {
      animarCaptura(pieza);
    }, 4000);
  </script>
</body>
</html>
